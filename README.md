# Оглавление
- [Инструкция](#инструкция)
  - [Задание](#задание)
    - [Необходимо](#необходимо)
  - [Решение](#решение)
    - [Dockerfile](#dockerfile)
      - [Проверка (дополнительно)](#проверка-дополнительно)
    - [.env и .env.example](#env-и-envexample)
    - [docker-compose.yml](#docker-composeyml)
      - [db](#db)
      - [myapp](#myapp)
  - [Запуск. Вывод](#запуск-вывод)

# Инструкция

Для первого запуска:
```
cp .env.example .env // создать .env на основе шаблона
docker compose up [-d] [--build] // запуск контейнеров
```
Развернул тут ради интереса [http://94.183.232.41:8080/](http://94.183.232.41:8080/) (браузер может подставить https,чтоб открылось нужен http)
# Задание

Для сборки приложения в Dockerfile необходимо использовать образ golang:1.24.9

Скрипт сборки приложения:
```console
$ go mod download && go mod verify
$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -x -v -o file_path main.go
```
, где file_path - путь куда необходимо положить исполняемый файл приложения

Для корректной работы приложения необходимо внутри docker контейнера насположить директорию ui из репозитория рядом с приложением.

Запрос для проверки жизнеспособности контейнера GET /healthcheck.
Если сервис возвращает статус ответа 200 OK, значит с приложением всё нормально. Если иной статус ответа, то приложение не работает. 
Приложение запускает http сервер на порту 8080.
Для подключения к базе данных Postgresql необходимо указать переменную окружения DB. Значение для переменной окружения должно иметь следующий вид: postgres://username:password@host:port/database?sslmode=disable
, где:
* username - логин пользователя базы данных
* password - пароль пользователя базы данных
* host - доменное имя или ip адрес базы данных
* port - порт, на котором доступна база данных
* database - название базы данных, к которой необходимо подключиться

## Необходимо

1. Создать Dockerfile для сборки образа приложения
2. Настроить docker-compose таким образом, чтобы сначала запускалась база данных Postgresql, а только потом сервис.
3. Настроить проверку работоспособности контейнера, с помощью запроса GET /healthcheck

# Решение

## Dockerfile

Для создания образа приложения, в корневой директории проекта создаю файл "Dockerfile". Он содержит все необходимые для этого инструкции.

```Dockerfile
FROM golang:1.24.9 AS builder
```
Эта инструкция задает базовый (родительский) образ golang для сборки самого приложения, также задаем имя builder чтобы позже ссылаться на него

```Dockerfile
WORKDIR /src
```
Здесь с помощью WORKDIR задаю рабочую директорию внутри контейнера, все последующие инструкции будут выполняться относительно нее

```Dockerfile
COPY go.mod go.sum ./
RUN go mod download && go mod verify
```
Копирую из директории проекта в контейнер файлы go.mod go.sum (зависимости Go проекта) и с помощью RUN выполняю соответствующие команды для установки  и проверки зависимостей.
Делаю это отдельно перед копированием кода и всем остальным, так как код приложения как правило обновляется чаще, чем зависимости. Инструкции COPY и RUN создают слои образа, которые докер кеширует в той же последовательности, как и в файле. Если будет, например, изменен код, но нетронуты зависимости, при следующей пересборке образа для зависимостей докер возьмет уже имеющиеся слои из кеша. Тем самым мы оптимизируем сборку образа.

```dockerfile
COPY main.go ./
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -x -v -o /out/myapp main.go
```
Теперь копирую сам код и выполняю команду для сборки go приложения. Указываю путь. куда положить исполняемый файл как /out/myapp . В данном случае это будет директория внутри контейнера рядом с /src (так как указан абсолютный путь)

```Dockerfile
FROM alpine:3.22
```
Здесь начинается следующий этап уже для запуска собранного приложения, задаю снова базовый образ как Alpine Linux. Он минимальный, весит мало и подойдет для запуска готового Go приложения. Для текущих задач будет достаточно. Указываю конкретную версию, чтоб точно везде работало одинаково, в отличие от просто последней версии latest, которая меняется.

```Dockerfile
WORKDIR /app
COPY --from=builder /out/myapp ./myapp
COPY ui/ ./ui/
```
Аналогично задаю рабочую директорию внутри контейнера /app.
Затем, используя имя builder предыдущего этапа, достаю из его директории /out/myapp полученный ранее исполняемый файл и копирую в директорию текущего нового образа /app/myapp .
Далее копирую с хоста из корня проекта директорию ui, необходимую для работы приложения, и кладу ее рядом с исполняемым файлом (/app/ui).

В данный момент существует как бы два образа: builder, который уже собран и пока что хранится в кеше докера и новый alpine. Но, после финальной сборки, builder, использовавшийся как промежуточный образ, будет очищен из кеша и не войдет в итоговый образ

```Dockerfile
ENTRYPOINT ["./myapp"]
```
С помощью ENTRYPOINT задаю точку входа в контейнер, то есть команду, которая будет выполнятся при запуске. В данном случае просто запускает этот исполняемый файл приложения

### Проверка (дополнительно)

Не обязательно, но можно проверить как собирается образ отдельно командой
```sh
docker build . -t myapp:1.0.0
```
Флаг -t указывает название создаваемого образа, тег если нужно. Точка ищет Dockerfile по умолчанию в данной директории, откуда вызывают. 

Посмотрим вывод docker images
```
REPOSITORY    TAG         IMAGE ID       CREATED        SIZE
myapp         1.0.0       e4afa39a64a9   24 hours ago   32.1MB
...
```
Видим полученный образ myapp весом 32 мб. Этот образ содержит уже только alpine linux с исполняемым файлом и ui в директории /app.

Сам образ golang, который был промежуточным для сборки, весит много и в итоговый образ не входит. Можно посмотреть сколько бы весил образ с ним с помощью флага --target builder при сборке. (docker build . --target builder -t myapp:1.0.0)
```
REPOSITORY    TAG         IMAGE ID       CREATED              SIZE
myapp         1.0.0       f06b527466c4   About a minute ago   1.27GB
```

## .env и .env.example

Перед созданием docker-compose.yml определяю переменные окружения в специальном файле .env (файл окружения). 
```env                                                                          
POSTGRES_USER=root
POSTGRES_PASSWORD=admin
POSTGRES_DB=sandboxdb
DB_HOST=db
DB_PORT=5432

MYAPP_PORT=8080
```
Здесь задаю переменные для СУБД: пользователь, пароль, название БД, также хост, где находится база (в данном случае просто имя сервиса docker-compose, что указывает на контейнер) и порт.
Затем задаю еще порт, через который будет доступно приложение.

В данном случае здесь значения переменных для примера, но они могут быть изменены на реальные, поэтому этот файл не коммитится в репозиторий. Для этих целей создаю еще один файл .env.example, с такой же структурой, который будет находится в репозитории и представлять собой шаблон для файла .env

## docker-compose.yml

Теперь перехожу к файлу docker-compose.yml.

### db

В блоке services описываются сервисы, которые должны запускаться и работать.
```yml
db:
  image: postgres:16-alpine
  volumes:
    - db_data:/var/lib/postgresql/data
```
Сначала блок db (контейнер базы данных). В image указываю образ, который будет использоваться для СУБД postgres:16-alpine. Аналогично беру облегченную версию postgres на alpine linux.

Следом указываю в блоке volumes именованный том db_data. Это означает, что данные БД из контейнера (по пути /var/lib/postgresql/data) будут сохранятся в хостовую директорию db_data. Это нужно, чтобы данные сохранялись между перезапусками/удалениями контейнера

```yml
restart: always
```
Эта инструкция означает, что контейнер будет автоматически перезапускаться, если он упадет или если перезапущен докер.

```yml
environment:
  POSTGRES_USER: ${POSTGRES_USER:? set in .env}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?}
  POSTGRES_DB: ${POSTGRES_DB:?}
  POSTGRES_PORT: ${DB_PORT:?}
```
Теперь в блоке environment указываю переменные окружения, необходимые для запуска СУБД postgres, значения берутся как раз из файла .env .
конструкция :? означает, что если переменная не определена, докер выдаст ошибку и не запустит контейнер. В первом случае показан также пример вывода доп. сообщения set in .env

```yml
healthcheck:
  test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
  interval: 5s
  timeout: 5s
  retries: 20
  start_period: 10s
```
В блоке healthcheck указывается проверка здоровья контейнера. Дело в том, что контейнер может быть запущен, но бд внутри него еще не готова принимать соединения. Сам по себе докер просто так это не проверит, так как он просто запускает контейнер, поэтому для этого нужен healthcheck. 
Основная проверка готовности бд происходит командой указанной в **test**:
"CMD-SHELL" вызывает в контейнере СУБД команду начиная с /bin/sh -c 
pg_isready - утилита postgres для проверки готовности принять соединение, которая в свою очередь здесь принимает параметры -U (имя пользователя) -d (имя бд). (если все ок - exit 0)

**interval** - с каким интервалом проводить проверку, в данном случае через каждые 5 секунд
**timeout** - ожидание ответа, то есть если команда из test выполняется дольше 5 секунд, выполнение команды прерывается и попытка считается неудачной.
**retries** - количество попыток, в данном случае если больше 20 подряд неудачны, контейнер считается unhealthy
**start_period** - дает время на запуск и не учитывает неудачные попытки в retries (на случай всяких задержек). То есть сразу после запуска docker compose у контейнера есть 10 секунд, пока не начались считаться неудачные попытки выполнения test. Конечно здесь использовать не обязательно, т.к. контейнер легкий и стартует мгновенно.

Коротко алгоритм здесь следующий:
- Если команда успешно завершилась (код выхода 0) -  контейнер сразу считается healthy.
- Если команда вернула код ≠ 0 или не завершилась за **timeout** секунд,  это считается одной неудачной попыткой.
- После **retries** неудачных попыток подряд (за пределами **start_period**) контейнер становится unhealthy.

### myapp

Теперь блок myapp (само запускаемое приложение)
```yml
myapp:
  build:
    context: .
    dockerfile: Dockerfile
  image: myapp:1.0.0
```
Здесь использую блок build для описания того, что образ должен быть собран из Dockerfile в данной директории. В image даю ему название и тег

```yml
depends_on:
  db:
    condition: service_healthy
    restart: true
```
Здесь настраивается зависимость от БД. В depends_on прописываю название сервиса (db), что означает запуск сервиса myapp только после db. Но этого недостаточно, так как помимо запуска просто контейнера, нужно дождаться и запуска самой БД в контейнере, иначе приложение не сможет подключиться. Для этого используется **condition: service_healthy**, что позволяет учитывать статус здоровья зависимого контейнера. И теперь помимо прочего сервис ожидает статус healthy у сервиса db, который в свою очередь получается после запуска именно базы, как описано выше. **restart: true** позволяет в случае перезапуска сервиса db через compose, то сервис myapp тоже автоматически корректно перезапустится.

```yaml
ports:
  - "${MYAPP_PORT:-8080}:8080"
```
Здесь настраиваются порты. Слева указывается порт по которому приложение будет доступно вне контейнера на хосте (localhost или 127.0.0.1). Указывается переменной окружения или по умолчанию 8080. 
Справа указывается порт внутри контейнера на котором он слушает приложение. Само приложение в нашем случае запускает http сервер на порту 8080, поэтому в контейнере его на нем и необходимо слушать.

```yaml
environment:
  DB: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${DB_HOST:?}:${DB_PORT}/${POSTGRES_DB}?sslmode=disable
```
Здесь указывается переменная окружения DB, необходимая приложению для подключения к БД. Все значения также подставляются из .env

```yml
healthcheck:
  test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:8080/healthcheck || exit 1"]
  interval: 30s
  timeout: 5s
  retries: 3
  start_period: 10s
```
Также прописываю healthcheck по аналогии с сервисом db, только здесь команда **test** проверяет работоспособность контейнера, с помощью запроса GET /healthcheck. Если сервис возвращает статус ответа 200 OK (exit 0), значит с приложением всё нормально. Если иной статус ответа, то приложение не работает (exit 1).

```yml
volumes:
  db_data: 
```
В конце файла в volumes указываю используемый хостовой том (для данных с db) 


## Запуск. Вывод

Таким образом, с помощью Docker мы произвели контейнеризацию и запустили приложение:
1. Создали Dockerfile для сборки образа приложения
2. Настроили docker-compose таким образом, чтобы сначала запускалась база данных Postgresql, а только потом сервис.
3. Настроили проверку работоспособности контейнера, с помощью запроса GET /healthcheck

Теперь его можно запустить с помощью команды docker compose up.

![](https://i.postimg.cc/j2v0Mm0H/Pasted-image-20251031155404.jpg)
Видим последовательный запуск, сначала db потом myapp.

![](https://i.postimg.cc/rFpv8hLT/Pasted-image-20251031155508.jpg)
docker ps показывает, что все контейнеры healthy.

И приложение успешно запущено и доступно по http://127.0.0.1:8080 или http://localhost:8080
![](https://i.postimg.cc/XNszDwBr/Pasted-image-20251031155707.jpg)
Также после удаления контейнеров docker compose down и пересоздания видим, что база данных не очистилась. Если нужно очистить, добавляется флаг -v
